---
title: "human-fgsea-ranked-SEG-generic"
author: "S2599932"
date: "2024-07-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# For E-MTAB-3929

```{r}
data_dir <- "/home/s2599932/study-datasets/E-MTAB-3929_self_processed/E-MTAB-3929_counts.csv"
targets_dir <- "/home/s2599932/study-datasets/E-MTAB-3929_arrayexpress_downloaded/E-MTAB-3929_targets.csv"
```

```{r}
library(tidyverse)
library(scMerge)
library(SingleCellExperiment)
library(scater)
library(scran)
library(biomaRt)
library(org.Hs.eg.db)
library(AnnotationDbi)
```

## Read in the data and and annotation information
```{r}
raw <- read.csv(data_dir, header = TRUE, row.names = 1)
annotation <- read.csv(targets_dir, header = TRUE, row.names = "run_accession")
annotation <- annotation[match(colnames(raw), rownames(annotation)), ]
```

## Extract the human stably expressed genes from scMerge package
```{r}
# Load in hSEG
data("segList_ensemblGeneID", package = "scMerge")
hSEG <- segList_ensemblGeneID$human$human_scSEG
```

## Create the Single Cell Experiment Object (SCE)
```{r}
sce_raw <- SingleCellExperiment(
  assays = list(counts = as.matrix(raw)),
  colData = annotation
)
```

## Quality Control
### Retrieve the mitochondrial genes for humans
```{r}
# Connect to the Ensembl BioMart database
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Query for mitochondrial genes
mitogenes <- getBM(
    attributes = c("ensembl_gene_id", "external_gene_name"),
    filters = "chromosome_name",
    values = "MT",
    mart = ensembl
)

# Extract the ensembl_gene_id column and combine into a single string
mitogenes_ensembl_ids <- paste(mitogenes$ensembl_gene_id, collapse = "|")
```

### Check for mitochondial genes (ERCC Not Present)
```{r}
is_mito <- grepl(mitogenes_ensembl_ids, rownames(sce_raw))
sce_raw$qc_stats <- perCellQCMetrics(sce_raw, subsets = list(Mt=is_mito))
```
### QC Plots

```{r}
hist(sce_raw$qc_stats$sum/1e6, 
     xlab="Library sizes (millions)", 
     main="Histogram of Library Sizes", 
     breaks=20, 
     col="grey80", 
     ylab="Number of cells")
```

```{r}
hist(sce_raw$qc_stats$detected, 
     xlab="Number of detected genes", 
     main="Histogram of Detected Genes", 
     breaks=20, 
     col="grey80", 
     ylab="Number of cells")
```

```{r}
hist(sce_raw$qc_stats$subsets_Mt_percent,
     xlab="Mitochondrial proportion (%)", 
     main="Histogram of Mitochondrial Proportion", 
     breaks=20, 
     col="grey80", 
     ylab="Number of cells")
```

### Drop samples based on QC metrics
```{r}
libsize_drop <- isOutlier(sce_raw$qc_stats$sum, nmads = 3, type = "lower", log = TRUE)
feature_drop <- isOutlier(sce_raw$qc_stats$detected, nmads = 3, type = "lower", log = TRUE)
mito_drop <- isOutlier(sce_raw$qc_stats$subsets_Mt_percent, nmads = 3, type = "higher")

sce_fil <- sce_raw[,!(libsize_drop|feature_drop|mito_drop)]

filtered_cells <- colnames(sce_fil)
```

> 1529 to 1407 cells/samples

## Now subset the SCE object into two objects **(remember what each sce_subset stands for)**
```{r}
print(unique(colData(sce_raw)$development_stage))
```

```{r}
# Subset the SCE object for "embryonic day 3" and "embryonic day 4"
sce_one <- sce_fil[, colData(sce_fil)$development_stage %in% c("embryonic day 3", "embryonic day 4")]

# Subset the SCE object for "embryonic day 6" and "embryonic day 7"
sce_two <- sce_fil[, colData(sce_fil)$development_stage %in% c("embryonic day 6", "embryonic day 7")]
```

```{r}
length(colnames(sce_one@assays@data$counts))
length(colnames(sce_two@assays@data$counts))
```

### Normalize each of the datasets using deconvolution normalization
```{r}
clusters <- quickCluster(sce_fil)
sce_fil <- computeSumFactors(sce_fil, clusters = clusters)
sce_fil <- logNormCounts(sce_fil)
```

```{r}
clust1 <- quickCluster(sce_one)
sce_one <- computeSumFactors(sce_one, clusters = clust1)
sce_one <- logNormCounts(sce_one)
```

```{r}
clust2 <- quickCluster(sce_two)
sce_two <- computeSumFactors(sce_two, clusters = clust2)
sce_two <- logNormCounts(sce_two)
```

### PCA Plot for the unsubsetted dataset
```{r}
# Copy the SCE objects
sce_all_genes <- sce_fil
sce_hSEGs <- sce_fil

# Make sure to only use hSEGs that exist in the dataframe
if (is.character(hSEG)) {
  hSEG <- hSEG[hSEG %in% rownames(sce_hSEGs)]
}

sce_all_genes <- runPCA(sce_all_genes, subset_row = rownames(sce_all_genes))
sce_hSEGs <- runPCA(sce_hSEGs, subset_row = hSEG)
```

```{r}
cell_types <- colData(sce_fil)$development_stage

# Extract the PCA results
pca_results_1 <- reducedDim(sce_all_genes, "PCA")
pca_results_2 <- reducedDim(sce_hSEGs, "PCA")

# Create a dataframe for plotting
pca_df_1 <- data.frame(PC1 = pca_results_1[, 1],
                     PC2 = pca_results_1[, 2],
                     CellType = cell_types)

pca_df_2 <- data.frame(PC1 = pca_results_2[, 1],
                     PC2 = pca_results_2[, 2],
                     CellType = cell_types)

# Extract percentage of variance explained
variance_explained_1 <- attr(pca_results_1, "percentVar")
variance_explained_2 <- attr(pca_results_2, "percentVar")

# for each component
all_pc1 <- round(variance_explained_1[1],1)
all_pc2 <- round(variance_explained_1[2],1)

hseg_pc1 <- round(variance_explained_2[1],1)
hseg_pc2 <- round(variance_explained_2[2],1)
```

```{r fig.height=8, fig.width=10}
ggplot(pca_df_1, aes(x = PC1, y = PC2, color = CellType)) +
  geom_point(size = 2, alpha = 0.7) +
  scale_color_brewer(palette = "Set1") +
  theme_classic(base_size = 15) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title = element_text(face = "bold", size = 12),
    axis.text = element_text(color = "black"),
    legend.title = element_text(face = "bold", hjust = 0.5),
    legend.position = "right",
    legend.key.size = unit(0.8, "cm"),
    legend.text = element_text(size = 10),
    plot.margin = margin(20, 20, 20, 20)  # Add margins (top, right, bottom, left)
  ) +
  labs(
    title = "PCA of E-MTAB-3929 using hSEGs as features",
    x = paste("Principal Component 1 (", hseg_pc1, "%)", sep = ""),
    y = paste("Principal Component 2 (", hseg_pc2, "%)", sep = ""),
    color = "Cell Type"
  )
```

```{r fig.height=8, fig.width=10}
ggplot(pca_df_2, aes(x = PC1, y = PC2, color = CellType)) +
  geom_point(size = 2, alpha = 0.7) +
  scale_color_brewer(palette = "Set1") +
  theme_classic(base_size = 15) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title = element_text(face = "bold", size = 12),
    axis.text = element_text(color = "black"),
    legend.title = element_text(face = "bold", hjust = 0.5),
    legend.position = "right",
    legend.key.size = unit(0.8, "cm"),
    legend.text = element_text(size = 10),
    plot.margin = margin(20, 20, 20, 20)  # Add margins (top, right, bottom, left)
  ) +
  labs(
    title = "PCA of E-MTAB-3929 using hSEGs as features",
    x = paste("Principal Component 1 (", hseg_pc1, "%)", sep = ""),
    y = paste("Principal Component 2 (", hseg_pc2, "%)", sep = ""),
    color = "Cell Type"
  )
```

### Subset the SCE object and check what it does
```{r}
hSEG <- hSEG[hSEG %in% rownames(sce_raw)]

sce_hSEG <- sce_raw[rownames(sce_raw) %in% hSEG, ]
```

#### Mean variance plot
```{r}
# Load necessary libraries
library(SingleCellExperiment)
library(scran)
library(scater)

# Assume sce_fil is your SingleCellExperiment object

# Step 1: Quick clustering and normalization
clusters <- quickCluster(sce_fil)
sce_fil <- computeSumFactors(sce_fil, clusters = clusters)
sce_fil <- logNormCounts(sce_fil)

# Step 2: Model the gene variance
dec <- modelGeneVar(sce_fil)

# Examine the variance modeling results
head(dec)

# Step 3: Identify the top highly variable genes
# You can choose a threshold for the number of genes or based on biological relevance
top_hvgs <- getTopHVGs(dec, n = 2000)

# Print the top highly variable genes
print(top_hvgs)

# Optionally, you can visualize the variance to see how genes are spread
plot(dec$mean, dec$total, pch=16, cex=0.5, log="x", main="Gene Variance vs Mean",
     xlab="Mean expression", ylab="Total variance")
points(dec$mean[top_hvgs], dec$total[top_hvgs], col="red", pch=16, cex=0.5)

```
```{r}
# Load necessary libraries
library(SingleCellExperiment)
library(scran)
library(scater)

# Assume sce_fil is your SingleCellExperiment object

# Step 1: Normalize the data
clusters <- quickCluster(sce_fil)
sce_fil <- computeSumFactors(sce_fil, clusters = clusters)
sce_fil <- logNormCounts(sce_fil)

# Step 2: Model the gene variance
dec <- modelGeneVar(sce_fil)

# Step 3: Identify the top highly variable genes
top_hvgs <- getTopHVGs(dec, n = 2000)

# Step 4: Perform PCA using the fixedPCA function on the top highly variable genes
set.seed(100) # Set seed for reproducibility
sce_fil <- fixedPCA(sce_fil, subset.row = top_hvgs)

# Step 5: Check the results
reducedDimNames(sce_fil) # Check the reduced dimensions available

# Extract the PCA results for plotting or further analysis
pca_results <- reducedDim(sce_fil, "PCA")

# Optional: Create a dataframe for plotting
cell_types <- colData(sce_fil)$development_stage
pca_df <- data.frame(PC1 = pca_results[, 1],
                     PC2 = pca_results[, 2],
                     CellType = cell_types)

# Extract percentage of variance explained
variance_explained <- attr(pca_results, "percentVar")

# Round the percentage of variance explained
pc1_var <- round(variance_explained[1], 1)
pc2_var <- round(variance_explained[2], 1)
```

```{r fig.height=8, fig.width=10}
# Plot the PCA results
library(ggplot2)
ggplot(pca_df, aes(x = PC1, y = PC2, color = CellType)) +
  geom_point(size = 2, alpha = 0.7) +
  scale_color_brewer(palette = "Set1") +
  theme_classic(base_size = 15) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    legend.title = element_text(face = "bold", hjust = 0.5),
    legend.position = "right",
    legend.key.size = unit(0.8, "cm"),
    legend.text = element_text(size = 12),
    plot.margin = margin(20, 20, 20, 20)  # Add margins (top, right, bottom, left)
  ) +
  labs(
    title = "PCA of Single-Cell Data using top HVGs",
    x = paste("Principal Component 1 (", pc1_var, "%)", sep = ""),
    y = paste("Principal Component 2 (", pc2_var, "%)", sep = ""),
    color = "Cell Type"
  )
```



## Ranked SEG study
```{r}
# Ensure there are no NA values
sum(is.na(rowSums(logcounts(sce_one))))
sum(is.na(colSums(logcounts(sce_one))))

sum(is.na(rowSums(logcounts(sce_two))))
sum(is.na(colSums(logcounts(sce_two))))
```

```{r}
# Order the rownames of sce_emb_d3_d4
sce_one <- sce_one[order(rownames(sce_one), decreasing = FALSE), ]

# Order the rownames of sce_emb_d6_d7
sce_two <- sce_two[order(rownames(sce_two), decreasing = FALSE), ]
```

### Identify stably expressed genes in both susbsets
```{r}
sce_one_seg <- scSEGIndex(exprs(sce_one),cell_type = colData(sce_one)$development_stage,return_all = TRUE)
sce_two_seg <- scSEGIndex(exprs(sce_two),cell_type = colData(sce_two)$development_stage,return_all = TRUE)
```

### Compute the rank difference
```{r}
# arrange the data frames in descending order
sce_one_seg <- sce_one_seg %>% 
  arrange(desc(segIdx))

sce_two_seg <- sce_two_seg %>% 
  arrange(desc(segIdx))

# Save a copy of each
one_seg <- sce_one_seg
two_seg <- sce_two_seg
```

```{r}
sce_one_seg$segIdx_one <- rank(-1 * sce_one_seg$segIdx, ties.method = "average")
sce_two_seg$segIdx_two <- rank(-1 * sce_two_seg$segIdx, ties.method = "average")

sce_one_seg$segIdx_two <- sce_two_seg[rownames(sce_one_seg),]$segIdx_two
sce_two_seg$segIdx_one <- sce_one_seg[rownames(sce_two_seg),]$segIdx_one

sce_one_seg$segIdx_one_vs_two <- sce_one_seg$segIdx_one - sce_one_seg$segIdx_two
sce_two_seg$segIdx_two_vs_one <- sce_two_seg$segIdx_two - sce_two_seg$segIdx_one

sce_one_seg <- sce_one_seg %>% 
  arrange(desc(segIdx))
sce_two_seg <- sce_two_seg %>% 
  arrange(desc(segIdx))

sce_one_df <- as.data.frame(sce_one_seg)
sce_two_df <- as.data.frame(sce_two_seg)
```

### Map the ensembl IDs to entrez IDs
```{r}
# Extract the ensembl IDs
ensemblIDs <- rownames(sce_one_df)

# Map Ensembl IDs to Entrez IDs using org.Hs.eg.db
mapped_entrez <- mapIds(org.Hs.eg.db,
                        keys = ensemblIDs,
                        column = "ENTREZID",
                        keytype = "ENSEMBL",
                        multiVals = "first")

mapped_entrez <- data.frame(
  gene = names(mapped_entrez),
  EntrezID = as.character(mapped_entrez),
  stringsAsFactors = FALSE
)

# Inner join with sce_one_df
sce_one_df <- inner_join(sce_one_df, mapped_entrez, by = c("gene" = "gene"))

# Inner join with sce_two_df
sce_two_df <- inner_join(sce_two_df, mapped_entrez, by = c("gene" = "gene"))
```

### Get the gene biotype information of genes whose ensembl ID did not map to a entrez ID
```{r}
# Count and inspect the unmapped Ensembl IDs
unmapped_ensembl_ids <- ensemblIDs[is.na(mapped_entrez$EntrezID)]
num_unmapped <- sum(is.na(sce_one_df$EntrezID))
print(paste("Number of unmapped Ensembl IDs:", num_unmapped))

# Optional: Save the unmapped Ensembl IDs to a file for further inspection
write.csv(unmapped_ensembl_ids, "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/E-MTAB-3929/unmapped_ensembl_ids.csv", row.names = FALSE)

# Retrieve the gene types for the unmapped Ensembl IDs
gene_info <- getBM(attributes = c('ensembl_gene_id', 'gene_biotype'),
                   filters = 'ensembl_gene_id',
                   values = unmapped_ensembl_ids,
                   mart = ensembl)

# Convert gene_info to a data frame
gene_info_df <- as.data.frame(gene_info)

# Write out the gene information 
write.csv(gene_info_df, "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/E-MTAB-3929/gene_info_df.csv", row.names = FALSE)
```

#### Create a barplot to visualize the gene biotypes
```{r fig.height=8, fig.width=10}
# Create a bar plot for unmapped gene biotypes
ggplot(gene_info_df, aes(x = gene_biotype)) +
  geom_bar(fill="blue", color="black") +
  labs(title="Distribution of Unmapped Gene Biotypes", x="Gene Biotypes", y="Frequency") +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title.x = element_text(size = 12, face = "bold"),
    axis.title.y = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    plot.margin = unit(c(1, 1, 1, 1), "cm")  # Top, right, bottom, left
  )
```
### Nature compatible figures
```{r fig.height=6, fig.width=8}
# Load necessary libraries
library(ggplot2)
library(extrafont)

# Create the bar plot with specified formatting
plot <- ggplot(gene_info_df, aes(x = gene_biotype)) +
  geom_bar(fill="blue", color="black") +
  labs(title="Distribution of Unmapped Gene Biotypes", x="Gene Biotypes", y="Frequency") +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 8, face = "bold", family = "sans"),
    axis.title.x = element_text(size = 7, face = "bold", family = "sans"),
    axis.title.y = element_text(size = 7, face = "bold", family = "sans"),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 5, family = "sans"),
    axis.text.y = element_text(size = 5, family = "sans"),
    plot.margin = unit(c(1, 1, 1, 1), "cm")  # Top, right, bottom, left
  )

# Save the plot as a high-quality PDF vector file
ggsave("unmapped_gene_biotypes.pdf", plot = plot, width = 8, height = 6, units = "in", dpi = 300)

print(plot)
```


### Check dimension
```{r}
dim(sce_one_df)
dim(sce_two_df)
```

### Remove data for non coding genes
```{r}
# Remove the genes from the data frame that were unmapped (mostly pseudo genes and non coding RNA)
sce_two_df <- sce_two_df %>%
  filter(!is.na(EntrezID))
sce_one_df <- sce_one_df %>%
  filter(!is.na(EntrezID))
```

### Check dimension again
```{r}
dim(sce_one_df)
dim(sce_two_df)
```

### Map the entrez IDs to gene symbols
```{r}
# Retrieve gene symbols using org.Hs.eg.db
mapped_symbols <- mapIds(org.Hs.eg.db,
                         keys = sce_two_df$EntrezID,
                         column = "SYMBOL",
                         keytype = "ENTREZID",
                         multiVals = "first")

mapped_symbols <- data.frame(
  EntrezID = names(mapped_symbols),
  gene_symbol = as.character(mapped_symbols),
  stringsAsFactors = FALSE
)

# Add the gene symbols to the data frame
sce_one_df <- inner_join(sce_one_df, mapped_symbols, by = c("EntrezID" = "EntrezID"))
sce_two_df <- inner_join(sce_two_df, mapped_symbols, by = c("EntrezID" = "EntrezID"))

```

### Since there are many to many mappings hapenning we need to add an additional step (optional as many to many mappings is expected)
```{r}
# Check for duplicate values
# Check for duplicates in sce_one_df
dup_one <- sce_one_df %>% 
  group_by(EntrezID) %>% 
  filter(n() > 1) %>% 
  ungroup()

# Check for duplicates in sce_two_df
dup_two <- sce_two_df %>% 
  group_by(EntrezID) %>% 
  filter(n() > 1) %>% 
  ungroup()

# Print the number of duplicate rows found
print(paste("Number of duplicate rows in sce_one_df:", nrow(dup_one)))
print(paste("Number of duplicate rows in sce_two_df:", nrow(dup_two)))
```

```{r}
# Remove duplicates, keeping only the first occurrence
sce_one_df <- sce_one_df %>% 
  distinct(EntrezID, .keep_all = TRUE)

sce_two_df <- sce_two_df %>% 
  distinct(EntrezID, .keep_all = TRUE)

# Perform the join after removing duplicates
sce_one_df <- inner_join(sce_one_df, mapped_symbols, by = c("EntrezID" = "EntrezID"))
sce_two_df <- inner_join(sce_two_df, mapped_symbols, by = c("EntrezID" = "EntrezID"))
```


### Duplicates are present in the "gene" column so two ways to deal with them(either just keep the first occurence of each gene or just make the duplicate values unique)
#### make the duplicate values unique
```{r}
# Since there are duplicates in the gene column

# Load necessary libraries
library(dplyr)
library(tibble)

# Identify duplicate genes
duplicate_genes <- sce_one_df %>%
  group_by(gene) %>%
  filter(n() > 1) %>%
  ungroup() %>%
  dplyr::select(gene) %>%
  distinct()

print(duplicate_genes)

# Make gene names unique
sce_one_df_unique <- sce_one_df %>%
  mutate(gene = make.unique(as.character(gene)))

# Set the row names
rownames(sce_one_df_unique) <- sce_one_df_unique$gene

# Repeat for sce_two_df
sce_two_df_unique <- sce_two_df %>%
  mutate(gene = make.unique(as.character(gene)))

rownames(sce_two_df_unique) <- sce_two_df_unique$gene
```

```{r}
dim(sce_one_df_unique)
dim(sce_two_df_unique)
```

#### Only keep the first occurence of a gene (used)
```{r}
# Load necessary libraries
library(dplyr)
library(tibble)

# Identify duplicate genes
duplicate_genes <- sce_one_df %>%
  group_by(gene) %>%
  filter(n() > 1) %>%
  ungroup() %>%
  select(gene) %>%
  distinct()

print(duplicate_genes)

# Remove duplicates, keeping only the first occurrence
sce_one_df_unique <- sce_one_df %>%
  distinct(gene, .keep_all = TRUE)

# Set the row names
rownames(sce_one_df_unique) <- sce_one_df_unique$gene

# Repeat for sce_two_df
sce_two_df_unique <- sce_two_df %>%
  distinct(gene, .keep_all = TRUE)

rownames(sce_two_df_unique) <- sce_two_df_unique$gene

```

## Prepare the input named list for Gene Set Enrichment Analysis
```{r}
# Remove rows with NA or empty gene_symbol in the data frames
sce_one_df_clean <- sce_one_df %>%
  filter(!is.na(gene_symbol) & gene_symbol != "")

sce_two_df_clean <- sce_two_df %>%
  filter(!is.na(gene_symbol) & gene_symbol != "")

# Deal with duplicate values in the gene column
sce_one_df_unique <- sce_one_df_clean %>%
  distinct(gene, .keep_all = TRUE)
rownames(sce_one_df_unique) <- sce_one_df_unique$gene

sce_two_df_unique <- sce_two_df_clean %>%
  distinct(gene, .keep_all = TRUE)
rownames(sce_two_df_unique) <- sce_two_df_unique$gene

# Arrange both dataframes in descending order of the segIdx column
sce_one_df_unique <- sce_one_df_unique %>%
  arrange(desc(segIdx))

sce_two_df_unique <- sce_two_df_unique %>%
  arrange(desc(segIdx))
```
### Select the top 1000 stable genes from both the datasets
```{r}
# Select the first 1000 rows from the arranged data frame
sce_one_df_top1000 <- sce_one_df_unique %>%
  slice_head(n = 1000)

sce_two_df_top1000 <- sce_two_df_unique %>%
  slice_head(n = 1000)
```

```{r}
# Create the named list with the gene symbols as the named list
sce_one_ordered1000_lst <- setNames(sce_one_df_top1000$segIdx_one_vs_two, sce_one_df_top1000$gene_symbol)
sce_two_ordered1000_lst <- setNames(sce_two_df_top1000$segIdx_two_vs_one, sce_two_df_top1000$gene_symbol)

# Check for NA values
any(is.na(sce_one_ordered1000_lst))
any(is.na(sce_two_ordered1000_lst))
```

```{r}
write.csv(sce_one_ordered1000_lst,file = "./E-MTAB-3929/sce_d3_d4_lst.csv")
write.csv(sce_two_ordered1000_lst,file = "./E-MTAB-3929/sce_d6_d7_lst.csv")
```


## Perform GSEA using fgsea
```{r}
library(fgsea)
library(msigdb)
library(ExperimentHub)
library(GSEABase)
# Retrieve the MSigDB (Molecular Signatures Database) for Homo sapiens (human) using gene symbols (version 7.5.1)
# SYM is for gene symbols other possible values:'ENTREZ', 'ENSEMBL', 'REFSEQ', 'UNIPROT', 'HGNC'
msigdb.hs = getMsigdb(org = 'hs', id = 'SYM', version = '7.5.1')
msigdb.hs = appendKEGG(msigdb.hs)
msigdb.hs.list <- geneIds(msigdb.hs)

save(msigdb.hs.list, file = "./msigdb_hs_list.RData")
```

### For all pathways
```{r}
# for the first subset
fgsea_one <- fgsea(pathways = msigdb.hs.list, stats = sce_one_ordered1000_lst, nPermSimple = 100000)
fgsea_one <- fgsea_one %>%
  arrange(padj, desc(abs(NES)))

# for the second subset
fgsea_two <- fgsea(pathways = msigdb.hs.list, stats = sce_two_ordered1000_lst, nPermSimple = 100000)
fgsea_two <- fgsea_two %>%
  arrange(padj, desc(abs(NES)))
```

### For only hallmark pathways
```{r}
# Filter for Hallmark gene sets
hallmark_gene_sets_list <- msigdb.hs.list[grep("^HALLMARK_", names(msigdb.hs.list))]

# for the first subset
hallmark_fgsea_one <- fgsea(pathways = msigdb.hs.list, stats = sce_one_ordered1000_lst, nPermSimple = 100000)
hallmark_fgsea_one <- hallmark_fgsea_one %>%
  arrange(padj, desc(abs(NES)))

# for the second subset
hallmark_fgsea_two <- fgsea(pathways = msigdb.hs.list, stats = sce_two_ordered1000_lst, nPermSimple = 100000)
hallmark_fgsea_one <- hallmark_fgsea_one %>%
  arrange(padj, desc(abs(NES)))
```

### Check overlap between the named vector and the pathway list
```{r}
overlap_one <- intersect(names(sce_one_ordered1000_lst), unlist(msigdb.hs.list))
overlap_two <- intersect(names(sce_two_ordered1000_lst), unlist(msigdb.hs.list))
cat("Overlap for hESC:", length(overlap_one), "\n")
cat("Overlap for non-hESC:", length(overlap_two), "\n")
```
### Create p-value plot disturbing
```{r}
hist(fgsea_one$pval, breaks=50, main="P-value distribution for one", xlab="P-value")
hist(fgsea_two$pval, breaks=50, main="P-value distribution for two", xlab="P-value")
```

### Create adjusted p-value plot distributing
```{r}
hist(fgsea_one$padj, breaks=50, main="Adjusted P-value distribution for one", xlab="P-value")
hist(fgsea_two$padj, breaks=50, main="Adjusted P-value distribution for two", xlab="P-value")
```

### Save the fgsea results
```{r}
library(jsonlite)

# Function to convert list columns to JSON strings
convert_list_columns_to_json <- function(df) {
  list_columns <- sapply(df, is.list)
  df[list_columns] <- lapply(df[list_columns], function(col) {
    sapply(col, jsonlite::toJSON, auto_unbox = TRUE)
  })
  return(df)
}

# Convert the list to dataframe
fgsea_one <- convert_list_columns_to_json(as.data.frame(fgsea_one))
fgsea_two <- convert_list_columns_to_json(as.data.frame(fgsea_two))
hallmark_fgsea_one <- convert_list_columns_to_json(as.data.frame(hallmark_fgsea_one))
hallmark_fgsea_two <- convert_list_columns_to_json(as.data.frame(hallmark_fgsea_two))

# Save as csv files
write.csv(fgsea_one, file = "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/E-MTAB-3929/fgsea_one.csv", row.names = FALSE)
write.csv(fgsea_two, file = "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/E-MTAB-3929/fgsea_two.csv", row.names = FALSE)
write.csv(hallmark_fgsea_one, file = "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/E-MTAB-3929/hallmark_fgsea_one.csv", row.names = FALSE)
write.csv(hallmark_fgsea_two, file = "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/E-MTAB-3929/hallmark_fgsea_two.csv", row.names = FALSE)
```

