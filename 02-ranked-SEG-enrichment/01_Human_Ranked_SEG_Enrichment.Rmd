---
title: "human-ranked-SEG"
author: "S2599932"
date: "2024-07-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Start

```{r}
data_dir <- "/home/s2599932/study-datasets/GSE36552/GSE36552_counts.csv"
targets_dir <- "/home/s2599932/study-datasets/GSE36552/GSE36552_targets.csv"
```


```{r}
library(Seurat)
library(scMerge)
library(SingleCellExperiment)
library(ggplot2)
library(dplyr)
library(biomaRt)
library(corrplot)
library(scater)
library(scran)
library(biomaRt)
library(dplyr)
library(knitr)
```

## Read in the data and and annotation information
```{r}
raw <- read.csv(data_dir, header = TRUE, row.names = 1)
annotation <- read.csv(targets_dir, header = TRUE, row.names = "Run_Accession")
```

## Order the raw data
```{r}
# raw <- raw[,rownames(annotation)]
annotation <- annotation[match(colnames(raw), rownames(annotation)), ]
```

## Extract the human stably expressed genes from scMerge package
```{r}
# Load in hSEG
data("segList_ensemblGeneID", package = "scMerge")
hSEG <- segList_ensemblGeneID$human$human_scSEG
```

## Create the Single Cell Experiment Object (SCE)
```{r}
sce_raw <- SingleCellExperiment(
  assays = list(counts = as.matrix(raw)),
  colData = annotation
)
```

## Quality Control
### Retrieve the mitochondrial genes for humans
```{r}
# Connect to the Ensembl BioMart database
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Query for mitochondrial genes
mitogenes <- getBM(
    attributes = c("ensembl_gene_id", "external_gene_name"),
    filters = "chromosome_name",
    values = "MT",
    mart = ensembl
)

# Extract the ensembl_gene_id column and combine into a single string
mitogenes_ensembl_ids <- paste(mitogenes$ensembl_gene_id, collapse = "|")
```

### Check for mitochondial genes (ERCC Not Present)
```{r}
is_mito <- grepl(mitogenes_ensembl_ids, rownames(sce_raw))
sce_raw$qc_stats <- perCellQCMetrics(sce_raw, subsets = list(Mt=is_mito))
```

### Drop samples based on QC metrics
```{r}
libsize_drop <- isOutlier(sce_raw$qc_stats$sum, nmads = 3, type = "lower", log = TRUE)
feature_drop <- isOutlier(sce_raw$qc_stats$detected, nmads = 3, type = "lower", log = TRUE)
mito_drop <- isOutlier(sce_raw$qc_stats$subsets_Mt_percent, nmads = 3, type = "higher")

sce_fil <- sce_raw[,!(libsize_drop|feature_drop|mito_drop)]

filtered_cells <- colnames(sce_fil)
```

## Create subsets of the SCE object
```{r}
# Display the number of cells for each cell type
cell_type_counts <- table(sce_fil$Cell_Type)
print(cell_type_counts)
```

### SCE object for only Human Embryonic Stem Cells (hESC)
```{r}
# Assuming 'sce_fil' is your SingleCellExperiment object and 'Cell_Type' is a column in colData
hESC_cells <- which(colData(sce_fil)$Cell_Type == "human embryonic stem cell")

# Subset the SCE object
sce_hESC<- sce_fil[, colData(sce_fil)$Cell_Type == "human embryonic stem cell"]

# Now, you can subset the SingleCellExperiment object
cell_type_1 <- colData(sce_fil[, hESC_cells])$Cell_Type

```

### SCE object for remaining cells
```{r}
non_hESC_cells <- which(colData(sce_fil)$Cell_Type != "human embryonic stem cell")

sce_non_hESC<- sce_fil[, colData(sce_fil)$Cell_Type != "human embryonic stem cell"]

cell_type_2 <- colData(sce_fil[, non_hESC_cells])$Cell_Type
```

## Normalize all the SCE objects using deconvolution normalization
```{r}
# Original SCE object
clusters <- quickCluster(sce_fil, min.size = 10)
sce_fil <- computeSumFactors(sce_fil, clusters = clusters)
sce_fil <- logNormCounts(sce_fil)

# Human Embryonic Stem Cells
clust1 <- quickCluster(sce_hESC, min.size = 10)
sce_hESC <- computeSumFactors(sce_hESC, clusters = clust1)
sce_hESC <- logNormCounts(sce_hESC)

# Non hESCs
clust2 <- quickCluster(sce_non_hESC, min.size = 10)
sce_non_hESC <- computeSumFactors(sce_non_hESC, clusters = clust2)
sce_non_hESC <- logNormCounts(sce_non_hESC)
```

> The warnings have not been addressed yet.

## Create PCA plot for the original 
```{r}
# Copy the sce object
sce_fil_all_genes <- sce_fil
sce_fil_mSEG <- sce_fil

# Identify most variable genes in the dataset
# selected_genes <- rownames(sce_fil)[order(rowVars(assay(sce_fil)), decreasing=TRUE)[1:2000]]

if (is.character(hSEG)) {
  # Ensure all gene names in hSEG exist in sce_fil_mSEG
  hSEG <- hSEG[hSEG %in% rownames(sce_fil_mSEG)]
}

# Run PCA
sce_fil_all_genes <- runPCA(sce_fil_all_genes, subset_row = rownames(sce_fil_all_genes))
sce_fil_mSEG <- runPCA(sce_fil_mSEG, subset_row = hSEG)
```

```{r fig.height=6,fig.width=8}
cell_types <- colData(sce_fil)$Cell_Type

# Extract the PCA results
pca_results_1 <- reducedDim(sce_fil_all_genes, "PCA")
pca_results_2 <- reducedDim(sce_fil_mSEG, "PCA")

# Create a dataframe for plotting
pca_df_1 <- data.frame(PC1 = pca_results_1[, 1],
                     PC2 = pca_results_1[, 2],
                     CellType = cell_types)

pca_df_2 <- data.frame(PC1 = pca_results_2[, 1],
                     PC2 = pca_results_2[, 2],
                     CellType = cell_types)
```

```{r fig.height=8, fig.width=10}
# Plot the PCA results
ggplot(pca_df_1, aes(x = PC1, y = PC2, color = CellType)) +
  geom_point() +
  theme_minimal() +
  labs(title = "PCA of Single Cell Data",
       x = "Principal Component 1",
       y = "Principal Component 2")
```

```{r fig.height=8, fig.width=10}
# Plot the PCA results
ggplot(pca_df_2, aes(x = PC1, y = PC2, color = CellType)) +
  geom_point() +
  theme_minimal() +
  labs(title = "PCA of Single Cell Data",
       x = "Principal Component 1",
       y = "Principal Component 2")
```

## Prepare the dataset so that it is suitable for the next step
### Check for NA values
```{r}
# Ensure there are no NA values
sum(is.na(rowSums(logcounts(sce_hESC))))
sum(is.na(colSums(logcounts(sce_hESC))))

sum(is.na(rowSums(logcounts(sce_non_hESC))))
sum(is.na(colSums(logcounts(sce_non_hESC))))
```

### Extract and visualize the library sizes for Human Embryonic Stem Cell subset (Optional)
```{r}
# Calculate the sum of columns
colsums <- colSums(assay(sce_hESC, "counts"))

# Verify the length of colsums matches the number of columns in the assay
length(colsums) == ncol(sce_hESC)

# extract the log counts
sce_hESC_norm_counts <- logcounts(sce_hESC)[,colsums>100000]

# plot the histogram
hist(colSums(sce_hESC_norm_counts))
```

### Extract and visualize the library sizes for non hESC subset (Optional)
```{r}
# Calculate the sum of columns
colsums1 <- colSums(assay(sce_non_hESC, "counts"))

# Verify the length of colsums matches the number of columns in the assay
length(colsums1) == ncol(sce_non_hESC)

# Extract the log counts
sce_non_hESC_norm_counts <- logcounts(sce_non_hESC)[,colsums>100000]

# plot the histogram
hist(colSums(sce_non_hESC_norm_counts))
```

### Arrange the dataframes (NECESSARY)
```{r}
# Order the rownames of sce_hESC
sce_hESC <- sce_hESC[order(rownames(sce_hESC), decreasing = FALSE), ]

# Order the rownames of sce_non_hESC
sce_non_hESC <- sce_non_hESC[order(rownames(sce_non_hESC), decreasing = FALSE), ]
```


## For the nex part where the stably expressed genes are to be identified from the subsetted datasets the issue is that with the current dataset (GSE36552) when subetted into two objects one of the objects only contain cells of one type which causes error in the scSEGIndex() function during calculation of F-Statistics
- remove the cell type parameter from the scSEGIndex() function.

### Identify the SEGs without F-Staistics
```{r}
# Compute SEGs for non human embryonic stem cells
sce_non_hESC_seg <- scSEGIndex(exprs(sce_hESC), return_all = TRUE)
# Compute SEGs for human embryonic stem cells
sce_hESC_seg <- scSEGIndex(exprs(sce_non_hESC), return_all = TRUE)
```
### Check the dimensions of the SEG data frames
```{r}
print(dim(sce_hESC_seg))
print(dim(sce_non_hESC_seg))
```

```{r}
print(colnames(sce_hESC_seg))
print(colnames(sce_non_hESC_seg))
```

### Ommit the NA values (Remove later)
```{r eval=FALSE}
# Remove rows with NA values in the segIdx column
sce_hESC_seg <- sce_hESC_seg[!is.na(sce_hESC_seg$segIdx), ]
sce_non_hESC_seg <- sce_non_hESC_seg[!is.na(sce_non_hESC_seg$segIdx), ]
```


### Save the identified stably expressed genes
```{r}
write.csv(sce_hESC_seg, file = "./hESC_seg_GSE36552.csv", row.names = TRUE)
write.csv(sce_non_hESC_seg, file = "./non_hESC_seg_GSE36552.csv", row.names = TRUE)
```

### Arrange the dataframe in descending order of stability value (segIdx)
```{r}
# Arrange sce_hESC_seg in descending order of segIdx
sce_hESC_seg <- sce_hESC_seg %>% 
  arrange(desc(segIdx))

# Arrange sce_non_hESC_seg in descending order of segIdx
sce_non_hESC_seg <- sce_non_hESC_seg %>% 
  arrange(desc(segIdx))
```

### Rank the dataframes according to the SEG scores
```{r}
sce_hESC_seg$segIdx_hESC <- rank(-1 * sce_hESC_seg$segIdx, ties.method = "average")
sce_non_hESC_seg$segIdx_non_hESC <- rank(-1 * sce_non_hESC_seg$segIdx, ties.method = "average")
```

### Add the ranks of each dataframe in the other (precursor step to calulate the rank difference)
```{r}
sce_hESC_seg$segIdx_non_hESC <- sce_non_hESC_seg[rownames(sce_hESC_seg),]$segIdx_non_hESC
sce_non_hESC_seg$segIdx_hESC <- sce_hESC_seg[rownames(sce_non_hESC_seg),]$segIdx_hESC
```

### Compute the rank difference between the two
```{r}
sce_hESC_seg$segIdx_hESCvsnon_hESC <- sce_hESC_seg$segIdx_hESC - sce_hESC_seg$segIdx_non_hESC
sce_non_hESC_seg$segIdx_non_hESCvshESC <- sce_non_hESC_seg$segIdx_non_hESC - sce_non_hESC_seg$segIdx_hESC
```

### Rearrange the dataframes according to segIdx scores of the data frames
```{r}

sce_hESC_seg <- sce_hESC_seg %>% 
  arrange(desc(segIdx))


sce_non_hESC_seg <- sce_non_hESC_seg %>% 
  arrange(desc(segIdx))
```

### Prepare the input list for fgsea
```{r}
# Extract the top 1000 SEG genes 
sce_hESC_seg_1000 <-sce_hESC_seg[1:1000,]
sce_non_hESC_seg_1000 <-sce_non_hESC_seg[1:1000,]

# Arrange in descending order of the rank difference
sce_hESC_seg_1000 <- sce_hESC_seg_1000 %>% 
  arrange(desc(segIdx_hESCvsnon_hESC))
sce_non_hESC_seg_1000 <- sce_non_hESC_seg_1000 %>% 
  arrange(desc(segIdx_non_hESCvshESC))

# Make the input objects for enrichment - needs vector with rank values, names genes as row labels
sce_hESC_seg_1000_lst <- sce_hESC_seg_1000$segIdx_hESCvsnon_hESC
names(sce_hESC_seg_1000_lst) <- rownames(sce_hESC_seg_1000)

sce_non_hESC_seg_1000_lst <- sce_non_hESC_seg_1000$segIdx_non_hESCvshESC
names(sce_non_hESC_seg_1000_lst) <- rownames(sce_non_hESC_seg_1000)

# Remove NA values from the named vectors
sce_hESC_seg_1000_lst <- na.omit(sce_hESC_seg_1000_lst)
sce_non_hESC_seg_1000_lst <- na.omit(sce_non_hESC_seg_1000_lst)
```

### Write out the input list
```{r}
write.csv(sce_hESC_seg_1000_lst,file = "./sce_hESC_seg_1000_lst.csv")
write.csv(sce_non_hESC_seg_1000_lst,file = "./sce_non_hESC_seg_1000_lst.csv")
```



### Simpler way to map the ensembl IDs to gene symbols
```{r}
# Convert Ensembl IDs to gene symbols
ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
gene_annotations_hESC <- getBM(attributes = c('ensembl_gene_id', 'external_gene_name'),
                          filters = 'ensembl_gene_id',
                          values = rownames(sce_hESC_seg_1000),
                          mart = ensembl)
gene_annotations_non_hESC <- getBM(attributes = c('ensembl_gene_id', 'external_gene_name'),
                          filters = 'ensembl_gene_id',
                          values = rownames(sce_non_hESC_seg_1000),
                          mart = ensembl)

sce_hESC_seg_1000$external_gene_name <- gene_annotations_hESC$external_gene_name[match(rownames(sce_hESC_seg_1000), gene_annotations_hESC$ensembl_gene_id)]
sce_non_hESC_seg_1000$external_gene_name <- gene_annotations_non_hESC$external_gene_name[match(rownames(sce_non_hESC_seg_1000), gene_annotations_non_hESC$ensembl_gene_id)]
```

### Since not every ensembl ID mapped to a gene name we need to omit those rows in the dataframe
```{r}
sce_hESC_seg_1000 <- filter(sce_hESC_seg_1000, external_gene_name != "")
sce_non_hESC_seg_1000 <- filter(sce_non_hESC_seg_1000, external_gene_name != "")
```


### Download data from MsDB
```{r}
library(fgsea)
library(msigdb)
library(ExperimentHub)
library(GSEABase)

# Get the latest human data from MSigDB
msigdb.hs = getMsigdb(org = 'hs', id = 'SYM', version = '7.5.1') # grab latest human data

# Add KEGG pathways to the MSigDB data
msigdb.hs = appendKEGG(msigdb.hs) # add KEGG

# Extract gene sets into a list format
msigdb.hs.list <- geneIds(msigdb.hs)

# Optional: Save the list to a file for future use
# save(msigdb.hs.list, file = "msigdb_hs_list.RData")

```


### Prepare the input for fgsea
```{r}
# Prepare the ranked lists
sce_hESC_ordered1000_lst <- setNames(sce_hESC_seg_1000$segIdx_hESCvsnon_hESC, sce_hESC_seg_1000$external_gene_name)
sce_non_hESC_ordered1000_lst <- setNames(sce_non_hESC_seg_1000$segIdx_non_hESCvshESC, sce_non_hESC_seg_1000$external_gene_name)

```


```{r}
# Convert the ranked lists to named numeric vectors
mapped_hESC <- unlist(sce_hESC_ordered1000_lst)
names(mapped_hESC) <- names(sce_hESC_ordered1000_lst)

mapped_non_hESC <- unlist(sce_non_hESC_ordered1000_lst)
names(mapped_non_hESC) <- names(sce_non_hESC_ordered1000_lst)
```


### Do the FGSEA analysis
```{r}
# Perform FGSEA analysis with the human MSigDB list for hESC
fgsea_hESC_seg_1000_lstr <- fgsea(pathways = msigdb.hs.list, stats = mapped_hESC, nPermSimple = 200000)
fgsea_hESC_seg_1000_lstr <- fgsea_hESC_seg_1000_lstr[order(fgsea_hESC_seg_1000_lstr$padj, -abs(fgsea_hESC_seg_1000_lstr$NES)), ]

# Perform FGSEA analysis with the human MSigDB list for non-hESC
fgsea_non_hESC_seg_1000_lstr <- fgsea(pathways = msigdb.hs.list, stats = mapped_non_hESC, nPermSimple = 200000)
fgsea_non_hESC_seg_1000_lstr <- fgsea_non_hESC_seg_1000_lstr[order(fgsea_non_hESC_seg_1000_lstr$padj, -abs(fgsea_non_hESC_seg_1000_lstr$NES)), ]

```

#### WARNING BELOW

> # Perform FGSEA analysis with the human MSigDB list for hESC
> fgsea_hESC_seg_1000_lstr <- fgsea(pathways = msigdb.hs.list, stats = mapped_hESC, nPermSimple = 200000)
Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam,  :
  There are ties in the preranked stats (2.54% of the list).
The order of those tied genes will be arbitrary, which may produce unexpected results.
Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam,  :
  There are duplicate gene names, fgsea may produce unexpected results.
Warning in fgseaMultilevel(pathways = pathways, stats = stats, minSize = minSize,  :
  There were 40 pathways for which P-values were not calculated properly due to unbalanced (positive and negative) gene-level statistic values. For such pathways pval, padj, NES, log2err are set to NA. You can try to increase the value of the argument nPermSimple (for example set it nPermSimple = 2000000)
Warning in fgseaMultilevel(pathways = pathways, stats = stats, minSize = minSize,  :
  For some of the pathways the P-values were likely overestimated. For such pathways log2err is set to NA.
> fgsea_hESC_seg_1000_lstr <- fgsea_hESC_seg_1000_lstr[order(fgsea_hESC_seg_1000_lstr$padj, -abs(fgsea_hESC_seg_1000_lstr$NES)), ]
> 
> # Perform FGSEA analysis with the human MSigDB list for non-hESC
> fgsea_non_hESC_seg_1000_lstr <- fgsea(pathways = msigdb.hs.list, stats = mapped_non_hESC, nPermSimple = 200000)
Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam,  :
  There are ties in the preranked stats (1.65% of the list).
The order of those tied genes will be arbitrary, which may produce unexpected results.
Warning in fgseaMultilevel(pathways = pathways, stats = stats, minSize = minSize,  :
  There were 16 pathways for which P-values were not calculated properly due to unbalanced (positive and negative) gene-level statistic values. For such pathways pval, padj, NES, log2err are set to NA. You can try to increase the value of the argument nPermSimple (for example set it nPermSimple = 2000000)
> fgsea_non_hESC_seg_1000_lstr <- fgsea_non_hESC_seg_1000_lstr[order(fgsea_non_hESC_seg_1000_lstr$padj, -abs(fgsea_non_hESC_seg_1000_lstr$NES)), ]

### Since the adjusted p-values for both the dataframe are very high here are some trouble shooting steps to ensure that the issue is not with code
```{r}
overlap_hESC <- intersect(names(mapped_hESC), unlist(msigdb.hs.list))
overlap_non_hESC <- intersect(names(mapped_non_hESC), unlist(msigdb.hs.list))
cat("Overlap for hESC:", length(overlap_hESC), "\n")
cat("Overlap for non-hESC:", length(overlap_non_hESC), "\n")
```
> The high adjusted p-values are likely not due to insufficient overlap as overlap between ranked lists and the gene sets is reasonably good (818 for hESC and 869 for non-hESC)



```{r fig.width=8,fig.height=6}
hist(fgsea_hESC_seg_1000_lstr$padj, breaks=50, main="Adjusted P-value distribution for hESC", xlab="P-value")
hist(fgsea_non_hESC_seg_1000_lstr$padj, breaks=50, main="Adjusted P-value distribution for non-hESC", xlab="P-value")
```



#### just use hallmark gene sets
```{r}
# Example: focusing on a specific collection like Hallmark gene sets
hallmark_gene_sets <- msigdb.hs.list[grep("^HALLMARK_", names(msigdb.hs.list))]

hall_fgsea_hESC_seg_1000_lstr <- fgsea(pathways = hallmark_gene_sets, stats = mapped_hESC, nPermSimple = 200000)
hall_fgsea_non_hESC_seg_1000_lstr <- fgsea(pathways = hallmark_gene_sets, stats = mapped_non_hESC, nPermSimple = 200000)

hall_fgsea_hESC_seg_1000_lstr <- hall_fgsea_hESC_seg_1000_lstr[order(padj, -abs(NES)), ]
hall_fgsea_non_hESC_seg_1000_lstr <- hall_fgsea_non_hESC_seg_1000_lstr[order(padj, -abs(NES)), ]

```


```{r}
# Load jsonlite package
library(jsonlite)

# Function to convert list columns to JSON strings
convert_list_columns_to_json <- function(df) {
  list_columns <- sapply(df, is.list)
  df[list_columns] <- lapply(df[list_columns], function(col) {
    sapply(col, jsonlite::toJSON, auto_unbox = TRUE)
  })
  return(df)
}

# Convert list columns for each data frame
fgsea_hESC_seg_1000_lstr <- convert_list_columns_to_json(as.data.frame(fgsea_hESC_seg_1000_lstr))
fgsea_non_hESC_seg_1000_lstr <- convert_list_columns_to_json(as.data.frame(fgsea_non_hESC_seg_1000_lstr))
hall_fgsea_hESC_seg_1000_lstr <- convert_list_columns_to_json(as.data.frame(hall_fgsea_hESC_seg_1000_lstr))
hall_fgsea_non_hESC_seg_1000_lstr <- convert_list_columns_to_json(as.data.frame(hall_fgsea_non_hESC_seg_1000_lstr))

# Write each data frame to CSV files
write.csv(fgsea_hESC_seg_1000_lstr, file = "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/fgsea_results/fgsea_hESC_seg_1000_results.csv", row.names = FALSE)
write.csv(fgsea_non_hESC_seg_1000_lstr, file = "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/fgsea_results/fgsea_non_hESC_seg_1000_results.csv", row.names = FALSE)
write.csv(hall_fgsea_hESC_seg_1000_lstr, file = "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/fgsea_results/hallmark_fgsea_hESC_seg_1000_results.csv", row.names = FALSE)
write.csv(hall_fgsea_non_hESC_seg_1000_lstr, file = "/home/s2599932/MSc_DSB_Dissertation_2024/02-ranked-SEG-enrichment/fgsea_results/hallmark_fgsea_non_hESC_seg_1000_results.csv", row.names = FALSE)
```


### Perform david enrichment on the most changing genes (absolute difference rather than directional change)
- i.e. genes whose rank difference are the highest
```{r}
# Add columns for absolute rank differences
sce_hESC_seg_1000$abs_segIdx_hESCvsnon_hESC <- abs(sce_hESC_seg_1000$segIdx_hESCvsnon_hESC)
sce_non_hESC_seg_1000$abs_segIdx_non_hESCvshESC <- abs(sce_non_hESC_seg_1000$segIdx_non_hESCvshESC)

# Sort the data frames by the absolute rank difference columns in descending order
sce_hESC_sorted <- sce_hESC_seg_1000[order(sce_hESC_seg_1000$abs_segIdx_hESCvsnon_hESC, decreasing = TRUE), ]
sce_non_hESC_sorted <- sce_non_hESC_seg_1000[order(sce_non_hESC_seg_1000$abs_segIdx_non_hESCvshESC, decreasing = TRUE), ]

# Select the top 200 genes
top_200_hESC <- sce_hESC_sorted[1:200, ]
top_200_non_hESC <- sce_non_hESC_sorted[1:200, ]

# Extract the gene names for DAVID functional enrichment analysis
genes_for_david_hESC <- top_200_hESC$gene
genes_for_david_non_hESC <- top_200_non_hESC$gene

# Ensure no NA values in the gene lists
genes_for_david_hESC <- genes_for_david_hESC[!is.na(genes_for_david_hESC)]
genes_for_david_non_hESC <- genes_for_david_non_hESC[!is.na(genes_for_david_non_hESC)]
```

```{r}
# Save the gene lists to files for DAVID input
write.table(genes_for_david_hESC, "top_200_hESC_genes_for_david.txt", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(genes_for_david_non_hESC, "top_200_non_hESC_genes_for_david.txt", quote = FALSE, row.names = FALSE, col.names = FALSE)

# Save the hSEG list to be used as background
write.table(hSEG, "hSEG_list.txt", quote = FALSE, row.names = FALSE, col.names = FALSE)
```


