---
title: "human-ranked-SEG"
author: "S2599932"
date: "2024-07-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Start

```{r}
data_dir <- "/home/s2599932/study-datasets/GSE36552/GSE36552_counts.csv"
targets_dir <- "/home/s2599932/study-datasets/GSE36552/GSE36552_targets.csv"
```


```{r}
library(Seurat)
library(scMerge)
library(SingleCellExperiment)
library(ggplot2)
library(dplyr)
library(biomaRt)
library(corrplot)
library(scater)
library(scran)
library(biomaRt)
library(dplyr)
library(knitr)
library(fgsea)
```

## Read in the data and and annotation information
```{r}
raw <- read.csv(data_dir, header = TRUE, row.names = 1)
annotation <- read.csv(targets_dir, header = TRUE, row.names = "Run_Accession")
```

## Order the raw data
```{r}
# raw <- raw[,rownames(annotation)]
annotation <- annotation[match(colnames(raw), rownames(annotation)), ]
```

## Extract the human stably expressed genes from scMerge package
```{r}
# Load in hSEG
data("segList_ensemblGeneID", package = "scMerge")
hSEG <- segList_ensemblGeneID$human$human_scSEG
```

## Create the Single Cell Experiment Object (SCE)
```{r}
sce_raw <- SingleCellExperiment(
  assays = list(counts = as.matrix(raw)),
  colData = annotation
)
```

## Quality Control
### Retrieve the mitochondrial genes for humans
```{r}
# Connect to the Ensembl BioMart database
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Query for mitochondrial genes
mitogenes <- getBM(
    attributes = c("ensembl_gene_id", "external_gene_name"),
    filters = "chromosome_name",
    values = "MT",
    mart = ensembl
)

# Extract the ensembl_gene_id column and combine into a single string
mitogenes_ensembl_ids <- paste(mitogenes$ensembl_gene_id, collapse = "|")
```

### Check for mitochondial genes (ERCC Not Present)
```{r}
is_mito <- grepl(mitogenes_ensembl_ids, rownames(sce_raw))
sce_raw$qc_stats <- perCellQCMetrics(sce_raw, subsets = list(Mt=is_mito))
```

### Drop samples based on QC metrics
```{r}
libsize_drop <- isOutlier(sce_raw$qc_stats$sum, nmads = 3, type = "lower", log = TRUE)
feature_drop <- isOutlier(sce_raw$qc_stats$detected, nmads = 3, type = "lower", log = TRUE)
mito_drop <- isOutlier(sce_raw$qc_stats$subsets_Mt_percent, nmads = 3, type = "higher")

sce_fil <- sce_raw[,!(libsize_drop|feature_drop|mito_drop)]

filtered_cells <- colnames(sce_fil)
```

## Create subsets of the SCE object
```{r}
# Display the number of cells for each cell type
cell_type_counts <- table(sce_fil$Cell_Type)
print(cell_type_counts)
```

### SCE object for only Human Embryonic Stem Cells (hESC)
```{r}
# Assuming 'sce_fil' is your SingleCellExperiment object and 'Cell_Type' is a column in colData
hESC_cells <- which(colData(sce_fil)$Cell_Type == "human embryonic stem cell")

# Subset the SCE object
sce_hESC<- sce_fil[, colData(sce_fil)$Cell_Type == "human embryonic stem cell"]

# Now, you can subset the SingleCellExperiment object
cell_type_1 <- colData(sce_fil[, hESC_cells])$Cell_Type

```

### SCE object for remaining cells
```{r}
non_hESC_cells <- which(colData(sce_fil)$Cell_Type != "human embryonic stem cell")

sce_non_hESC<- sce_fil[, colData(sce_fil)$Cell_Type != "human embryonic stem cell"]

cell_type_2 <- colData(sce_fil[, non_hESC_cells])$Cell_Type
```

## Normalize all the SCE objects using deconvolution normalization
```{r}
# Original SCE object
clusters <- quickCluster(sce_fil, min.size = 10)
sce_fil <- computeSumFactors(sce_fil, clusters = clusters)
sce_fil <- logNormCounts(sce_fil)

# Human Embryonic Stem Cells
clust1 <- quickCluster(sce_hESC, min.size = 10)
sce_hESC <- computeSumFactors(sce_hESC, clusters = clust1)
sce_hESC <- logNormCounts(sce_hESC)

# Non hESCs
clust2 <- quickCluster(sce_non_hESC, min.size = 10)
sce_non_hESC <- computeSumFactors(sce_non_hESC, clusters = clust2)
sce_non_hESC <- logNormCounts(sce_non_hESC)
```

> The warnings have not been addressed yet.

## Create PCA plot for the original 
```{r}
# Copy the sce object
sce_fil_all_genes <- sce_fil
sce_fil_mSEG <- sce_fil

# Identify most variable genes in the dataset
# selected_genes <- rownames(sce_fil)[order(rowVars(assay(sce_fil)), decreasing=TRUE)[1:2000]]

if (is.character(hSEG)) {
  # Ensure all gene names in hSEG exist in sce_fil_mSEG
  hSEG <- hSEG[hSEG %in% rownames(sce_fil_mSEG)]
}

# Run PCA
sce_fil_all_genes <- runPCA(sce_fil_all_genes, subset_row = rownames(sce_fil_all_genes))
sce_fil_mSEG <- runPCA(sce_fil_mSEG, subset_row = hSEG)
```

```{r}
cell_types <- colData(sce_fil)$Cell_Type

# Extract the PCA results
pca_results_1 <- reducedDim(sce_fil_all_genes, "PCA")
pca_results_2 <- reducedDim(sce_fil_mSEG, "PCA")

# Create a dataframe for plotting
pca_df_1 <- data.frame(PC1 = pca_results_1[, 1],
                     PC2 = pca_results_1[, 2],
                     CellType = cell_types)

pca_df_2 <- data.frame(PC1 = pca_results_2[, 1],
                     PC2 = pca_results_2[, 2],
                     CellType = cell_types)
```

```{r fig.height=8, fig.width=10}
# Plot the PCA results
ggplot(pca_df_1, aes(x = PC1, y = PC2, color = CellType)) +
  geom_point() +
  theme_minimal() +
  labs(title = "PCA of Single Cell Data",
       x = "Principal Component 1",
       y = "Principal Component 2")
```

```{r fig.height=8, fig.width=10}
# Plot the PCA results
ggplot(pca_df_2, aes(x = PC1, y = PC2, color = CellType)) +
  geom_point() +
  theme_minimal() +
  labs(title = "PCA of Single Cell Data",
       x = "Principal Component 1",
       y = "Principal Component 2")
```

## Prepare the dataset so that it is suitable for the next step
### Check for NA values
```{r}
# Ensure there are no NA values
sum(is.na(rowSums(logcounts(sce_hESC))))
sum(is.na(colSums(logcounts(sce_hESC))))

sum(is.na(rowSums(logcounts(sce_non_hESC))))
sum(is.na(colSums(logcounts(sce_non_hESC))))
```

### Extract and visualize the library sizes for Human Embryonic Stem Cell subset
```{r}
# Calculate the sum of columns
colsums <- colSums(assay(sce_hESC, "counts"))

# Verify the length of colsums matches the number of columns in the assay
length(colsums) == ncol(sce_hESC)

# extract the log counts
sce_hESC_norm_counts <- logcounts(sce_hESC)[,colsums>100000]

# plot the histogram
hist(colSums(sce_hESC_norm_counts))
```

### Extract and visualize the library sizes for non hESC subset
```{r}
# Calculate the sum of columns
colsums1 <- colSums(assay(sce_non_hESC, "counts"))

# Verify the length of colsums matches the number of columns in the assay
length(colsums1) == ncol(sce_non_hESC)

# Extract the log counts
sce_non_hESC_norm_counts <- logcounts(sce_non_hESC)[,colsums>100000]

# plot the histogram
hist(colSums(sce_non_hESC_norm_counts))
```

## For the nex part where the stably expressed genes are to be identified from the subsetted datasets the issue is that with the current dataset (GSE36552) when subetted into two objects one of the objects only contain cells of one type which causes error in the scSEGIndex() function during calculation of F-Statistics
- remove the cell type parameter from the scSEGIndex() function.

### Identify the SEGs without F-Staistics
```{r}
# Compute SEGs for non human embryonic stem cells
sce_non_hESC_seg <- scSEGIndex(sce_non_hESC_norm_counts, return_all = TRUE)
# Compute SEGs for human embryonic stem cells
sce_hESC_seg <- scSEGIndex(sce_hESC_norm_counts, return_all = TRUE)
```
### Check the dimensions of the SEG data frames
```{r}
print(dim(sce_hESC_seg))
print(dim(sce_non_hESC_seg))
```

```{r}
print(colnames(sce_hESC_seg))
print(colnames(sce_non_hESC_seg))
```

### Arrange the dataframe in descending order of stability value (segIdx)
```{r}
# Arrange sce_hESC_seg in descending order of segIdx
sce_hESC_seg <- sce_hESC_seg %>% 
  arrange(desc(segIdx))

# Arrange sce_non_hESC_seg in descending order of segIdx
sce_non_hESC_seg <- sce_non_hESC_seg %>% 
  arrange(desc(segIdx))
```

### Rank the dataframes according to the SEG scores
```{r}
sce_hESC_seg$segIdx_hESC <- rank(-1 * sce_hESC_seg$segIdx, ties.method = "average")
sce_non_hESC_seg$segIdx_non_hESC <- rank(-1 * sce_non_hESC_seg$segIdx, ties.method = "average")
```

### Add the ranks of each dataframe in the other (precursor step to calulate the rank difference)
```{r}
sce_hESC_seg$segIdx_non_hESC <- sce_non_hESC_seg[rownames(sce_hESC_seg),]$segIdx_non_hESC
sce_non_hESC_seg$segIdx_hESC <- sce_hESC_seg[rownames(sce_non_hESC_seg),]$segIdx_hESC
```

### Compute the rank difference between the two
```{r}
sce_hESC_seg$segIdx_hESCvsnon_hESC <- sce_hESC_seg$segIdx_hESC - sce_hESC_seg$segIdx_non_hESC
sce_non_hESC_seg$segIdx_non_hESCvshESC <- sce_non_hESC_seg$segIdx_non_hESC - sce_non_hESC_seg$segIdx_hESC
```

### Rearrange the dataframes according to segIdx scores of the data frames
```{r}
# Arrange res_2i_ordered in descending order of segIdx
sce_hESC_seg <- sce_hESC_seg %>% 
  arrange(desc(segIdx))

# Arrange res_serum_ordered in descending order of segIdx
sce_non_hESC_seg <- sce_non_hESC_seg %>% 
  arrange(desc(segIdx))
```

### Prepare the input list for fgsea
```{r}
# Extract the top 1000 SEG genes 
sce_hESC_seg_1000 <-sce_hESC_seg[1:1000,]
sce_non_hESC_seg_1000 <-sce_non_hESC_seg[1:1000,]

# Arrange in descending order of the rank difference
sce_hESC_seg_1000 <- sce_hESC_seg_1000 %>% 
  arrange(desc(segIdx_hESCvsnon_hESC))
sce_non_hESC_seg_1000 <- sce_non_hESC_seg_1000 %>% 
  arrange(desc(segIdx_non_hESCvshESC))

# Make the input objects for enrichment - needs vector with rank values, names genes as row labels
sce_hESC_seg_1000_lst <- sce_hESC_seg_1000$segIdx_hESCvsnon_hESC
names(sce_hESC_seg_1000_lst) <- rownames(sce_hESC_seg_1000)

sce_non_hESC_seg_1000_lst <- sce_non_hESC_seg_1000$segIdx_non_hESCvshESC
names(sce_non_hESC_seg_1000_lst) <- rownames(sce_non_hESC_seg_1000)

# Remove NA values from the named vectors
sce_hESC_seg_1000_lst <- na.omit(sce_hESC_seg_1000_lst)
sce_non_hESC_seg_1000_lst <- na.omit(sce_non_hESC_seg_1000_lst)
```

### Write out the input list
```{r}
write.csv(sce_hESC_seg_1000_lst,file = "./sce_hESC_seg_1000_lst.csv")
write.csv(sce_non_hESC_seg_1000_lst,file = "./sce_non_hESC_seg_1000_lst.csv")
```

### Map the ensembl IDs to gene symbols
```{r}
# Use biomaRt to map Ensembl IDs to gene symbols
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl_ids_hESC <- names(sce_hESC_seg_1000_lst)
ensembl_ids_non_hESC <- names(sce_non_hESC_seg_1000_lst)

gene_mapping_hESC <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol"),
                           filters = "ensembl_gene_id",
                           values = ensembl_ids_hESC,
                           mart = ensembl)
gene_mapping_non_hESC <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol"),
                               filters = "ensembl_gene_id",
                               values = ensembl_ids_non_hESC,
                               mart = ensembl)

# Create a named vector with gene symbols as names and ranking values as values
gene_mapping_hESC <- gene_mapping_hESC[gene_mapping_hESC$hgnc_symbol != "", ]  # Remove entries without a gene symbol
gene_mapping_non_hESC <- gene_mapping_non_hESC[gene_mapping_non_hESC$hgnc_symbol != "", ]  # Remove entries without a gene symbol

# Merge with the ranking vectors
mapped_hESC <- sce_hESC_seg_1000_lst[gene_mapping_hESC$ensembl_gene_id]
names(mapped_hESC) <- gene_mapping_hESC$hgnc_symbol

mapped_non_hESC <- sce_non_hESC_seg_1000_lst[gene_mapping_non_hESC$ensembl_gene_id]
names(mapped_non_hESC) <- gene_mapping_non_hESC$hgnc_symbol

# Remove any NA values from the vectors
mapped_hESC <- na.omit(mapped_hESC)
mapped_non_hESC <- na.omit(mapped_non_hESC)
```


### Download data from MsDB
```{r}
# Load the packages
library(fgsea)
library(msigdb)
library(ExperimentHub)
library(GSEABase)

# Get the latest human data from MSigDB
msigdb.hs = getMsigdb(org = 'hs', id = 'SYM', version = '7.5.1') # grab latest human data

# Add KEGG pathways to the MSigDB data
msigdb.hs = appendKEGG(msigdb.hs) # add KEGG

# Extract gene sets into a list format
msigdb.hs.list <- geneIds(msigdb.hs)

# Optional: Save the list to a file for future use
save(msigdb.hs.list, file = "msigdb_hs_list.RData")


```


### Do the FGSEA analysis
```{r}
# Perform FGSEA analysis with the human MSigDB list
fgsea_hESC_seg_1000_lstr <- fgsea(pathways = msigdb.hs.list, stats = mapped_hESC, nPermSimple = 200000)
fgsea_hESC_seg_1000_lstr <- fgsea_hESC_seg_1000_lstr[order(padj, -abs(NES)), ]

fgsea_non_hESC_seg_1000_lstr <- fgsea(pathways = msigdb.hs.list, stats = mapped_non_hESC, nPermSimple = 200000)
fgsea_non_hESC_seg_1000_lstr <- fgsea_non_hESC_seg_1000_lstr[order(padj, -abs(NES)), ]
```

### Since the adjusted p-values for both the dataframe are very high here are some trouble shooting steps to ensure that the issue is not with code
```{r}
overlap_hESC <- intersect(names(mapped_hESC), unlist(msigdb.hs.list))
overlap_non_hESC <- intersect(names(mapped_non_hESC), unlist(msigdb.hs.list))
cat("Overlap for hESC:", length(overlap_hESC), "\n")
cat("Overlap for non-hESC:", length(overlap_non_hESC), "\n")
```
> The high adjusted p-values are likely not due to insufficient overlap as overlap between ranked lists and the gene sets is reasonably good (619 for hESC and 642 for non-hESC)

---
Given your reasonable overlap, the focus should be on the quality and appropriateness of the ranked list, the relevance of the gene sets, and the statistical power of the analysis. By carefully examining these factors and potentially increasing the number of permutations or focusing on a subset of gene sets, you can better understand why the adjusted p-values are high and take steps to address the issue. If you continue to face challenges, consulting with a bioinformatics expert may provide additional insights.
---

```{r fig.width=8,fig.height=6}
hist(fgsea_hESC_seg_1000_lstr$pval, breaks=50, main="P-value distribution for hESC", xlab="P-value")
hist(fgsea_non_hESC_seg_1000_lstr$pval, breaks=50, main="P-value distribution for non-hESC", xlab="P-value")
```

---
The histograms of p-value distributions for both hESC and non-hESC show a roughly uniform distribution of p-values. This suggests that there is no strong signal of enrichment in the data, as significant enrichment would typically result in a higher frequency of low p-values (near 0).
---

#### just use hallmark gene sets
```{r}
# Example: focusing on a specific collection like Hallmark gene sets
hallmark_gene_sets <- msigdb.hs.list[grep("^HALLMARK_", names(msigdb.hs.list))]
fgsea_hESC_seg_1000_lstr <- fgsea(pathways = hallmark_gene_sets, stats = mapped_hESC, nPermSimple = 200000)
fgsea_non_hESC_seg_1000_lstr <- fgsea(pathways = hallmark_gene_sets, stats = mapped_non_hESC, nPermSimple = 200000)

fgsea_hESC_seg_1000_lstr <- fgsea_hESC_seg_1000_lstr[order(padj, -abs(NES)), ]
fgsea_non_hESC_seg_1000_lstr <- fgsea_non_hESC_seg_1000_lstr[order(padj, -abs(NES)), ]

print(fgsea_hESC_seg_1000_lstr[1:20,])
print(fgsea_non_hESC_seg_1000_lstr[1:20,])
```





